//NAME:
//  main.c
//
//PURPOSE:
//  This C file is meant to be built with the Xilinx SDK and run as an
//  ELF file on a Microblaze processor.
//
//AUTHOR:
//  Lance Simms
//  Note: Code uses Xilinx examples included with Vivado.
//
//DATE:
//  01/09/17
//
/***************************** Include Files *********************************/

#include "xparameters.h"
#include <xil_printf.h>
#include <climits>
#include <stdio.h>
#include "xil_exception.h"
#include "xuartns550.h"
#include "xintc.h"
#include "xgpio_l.h"
#include "psram_ip.h"
#include "xcalc.h"
#include "microblaze_sleep.h"
#include "uartfuncs.h"

/************************** Constant Definitions *****************************/

/*
 * The following constants map to the XPAR parameters created in the
 * xparameters.h file. They are defined here such that a user can easily
 * change all the needed parameters in one place.
 */
#define UART_IRPT_INTR			XPAR_INTC_0_UARTNS550_0_VEC_ID
#define UART_BASE				XPAR_UARTNS550_0_BASEADDR
#define UART_CLOCK				XPAR_AXI_UART16550_0_CLOCK_FREQ_HZ
#define PSRAM_BASE				XPAR_PSRAM_IP_0_S00_AXI_BASEADDR
#define PSRAM_END				XPAR_PSRAM_IP_0_S00_AXI_HIGHADDR
#define CALC_DEVICE_ID			XPAR_CALC_0_DEVICE_ID
//#define GPIO_REG_BASEADDR		0x40000000


/*
 * The following constant controls the length of the buffers to be sent
 * and received with the Uart device.
 */
#define TEST_BUFFER_SIZE        500
#define FRAC_BITS				35
#define BAUD_RATE				250000U
#define LED_CHANNEL				1
#define	CHUNK_SIZE				1024 //Serial packet chunks for sending image data

/************************** Function Prototypes ******************************/

int CalcMandelbrot(INTC *IntcInstancePtr,	XUartNs550 *UartInstancePtr, u16 UartDeviceId, u16 UartIntrId);

void crc32(const void *data, size_t n_bytes, uint32_t* crc);

//static int GpioOutputExample(u32 LED_Value);

/************************** Variable Definitions *****************************/

 XUartNs550 UartNs550Instance;	 /* Instance of the UART Device */
 INTC IntcInstance;				 /* Instance of the Interrupt Controller */
 XIntc InterruptController;      /* The instance of the Interrupt Controller */
 XCalc Calc;					 /* The instance of the Mandelbrot Calc device */
 XCalc_Config *Calc_Cfg;		 /* The instance of the Calc config */

 /*
  * The following buffers are used in this example to send and receive data
  * with the Uart.
  */
 u8 SendBuffer[TEST_BUFFER_SIZE];
 u8 ReceiveBuffer[TEST_BUFFER_SIZE];

 /* Here are the pointers to the buffer */
 u8* ReceiveBufferPtr = &ReceiveBuffer[0];
 u8* CommandPtr       = &ReceiveBuffer[0];

 /*
  * The following counters are used to determine when the entire buffer has
  * been sent and received.
  */
 volatile int TotalReceivedCount;
 volatile int TotalSentCount;
 volatile int TotalErrorCount;

 // Coordinates for Mandelbrot set calculation to pass to the hardware - Upper left X/Y, Upper right X.
 u64 X0, X1, Y0;
 u16 WIDTH = 1024;  // Hardware supports up to 1920 wide. Do not exceed.
 u16 HEIGHT = WIDTH * 3 / 4;

 // For the serial port...
 u16 Options;
 u8 Errors;

 void printmem() {
		u16* buffer = (u16*)PSRAM_BASE;
		for (int y = 0; y < HEIGHT; y++) {
			for (int x = 0; x < WIDTH; x++) {
				xil_printf("%d ",*buffer++);
			}
			xil_printf("\r\n");
		}
 }

 void GetCommand(XUartNs550 *UartInstancePtr, u8 *ReceiveBufferPtr) {
	ReceiveBufferPtr[0] = 0;
	char SendStat[] = "READY\n";
	XUartNs550_Send(UartInstancePtr, (u8 *)SendStat, 6);
	//Wait for an incoming character
	while (ReceiveBufferPtr[0] == 0) {
		XUartNs550_Recv(UartInstancePtr, ReceiveBufferPtr, 1);
	}
 }

 void SerialSend(XUartNs550 *UartInstancePtr, u8 *sendBuffer, u32 TotalToSend) {

	 for (uint i = 0; i < TotalToSend / CHUNK_SIZE; i += CHUNK_SIZE) {
		 u32 crc;
		 crc32(&sendBuffer[i], CHUNK_SIZE, &crc);

		 XUartNs550_Send(UartInstancePtr, &sendBuffer[i], CHUNK_SIZE);
		 while (UartInstancePtr->SendBuffer.RemainingBytes != 0) {};

		 u8* ptr = (u8 *) &crc; //Get u8* pointer to the bytes of the CRC.
		 XUartNs550_Send(UartInstancePtr, ptr, sizeof(u32));
		 while (UartInstancePtr->SendBuffer.RemainingBytes != 0) {};
	 }

	 const char done = "DONE";
	 XUartNs550_Send(UartInstancePtr, done, 4);
	 while (UartInstancePtr->SendBuffer.RemainingBytes != 0) {};
 }

int main()
{

	//Variable definitions
	int Status = CalcMandelbrot(&IntcInstance, &UartNs550Instance, UART_DEVICE_ID, UART_IRPT_INTR);

	if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

	return Status;
}

int CalcMandelbrot(INTC *IntcInstancePtr,	XUartNs550 *UartInstancePtr, u16 UartDeviceId, u16 UartIntrId)
{
	int Status;

    //Set up the UART and configure the interrupt handler for bytes in RX buffer
	Status = UartSetup(IntcInstancePtr, UartInstancePtr, UartDeviceId, UartIntrId);
		if (Status != XST_SUCCESS) {
			return XST_FAILURE;
		}

	// Change the baud rate of the UART to 2Mbps, and indicate that incoming AXI clock is 100MHz.
	XUartNs550_SetBaud(UART_BASE, UART_CLOCK, BAUD_RATE);

#ifdef DEBUG
	//Fill 16MB empty memory with a recognizable pattern.
	xil_printf("Initializing memory\r\n");
	for (u32* x = (u32 *)PSRAM_BASE; x <= (u32 *)PSRAM_END - 1; x++) {
		 *x = 0xDEADBEEF;
	}
#endif

	// Set up the Mandelbrot calculator IP
	Status = XCalc_Initialize(&Calc, CALC_DEVICE_ID);

	if (Status != XST_SUCCESS) {
#ifdef DEBUG
		xil_printf("Failed to initialize Calc IP\r\n");
#endif
		return XST_FAILURE;
	}

	while (!XCalc_IsIdle(&Calc)) {} // Wait for IP to be Idle

#ifdef DEBUG
	xil_printf("Calc IP is ready.\r\n");
#endif

	// Wait for Go command.

	XUartNs550_ClearStats(UartInstancePtr);

	do {
		GetCommand(UartInstancePtr, ReceiveBufferPtr);
	} while (ReceiveBuffer[0] != 'G');


#ifdef DEBUG
	xil_printf("Calc IP starting.\r\n");
#endif

	/*	The set goes from -2 to 2 on the X axis, and -1 to 1 on the Y axis.
		Pick a 4:3 window specified by Top Left X/Y coordinate, Top Right X value. The rest is calculated.
		Values are 56-bit fixed point: Uppermost byte of ULL is not used, leaving 24+32 bits for fixed point numbers.
		After padding MSB by one byte, then 5 bits are used for sign and integer, remaining 51 bits for fractional portion.
	*/
	X0 = -2ULL << FRAC_BITS; //0x00F0000000000000ULL;//-2;
	X1 = 2ULL << FRAC_BITS; //30x0010000000000000ULL;//2;
	Y0 = 1ULL << FRAC_BITS; //0x0008000000000000ULL;//1;

	XCalc_Set_X0_V(&Calc, X0);
	XCalc_Set_X1_V(&Calc, X1);
	XCalc_Set_Y0_V(&Calc, Y0);
	XCalc_Set_width_V(&Calc, WIDTH);
    XCalc_Start(&Calc);

    // Wait for the full image to iterate.
    while (!XCalc_IsDone(&Calc)) {};

#ifdef DEBUG
    xil_printf("Calc IP is done.\r\n");
#endif

    // Send the contents of image memory to the serial port.
    TotalSentCount = 0;
    int TotalToSend = HEIGHT * WIDTH * sizeof(u16);
    XUartNs550_ClearStats(UartInstancePtr);

    SerialSend(UartInstancePtr, (u8 *) PSRAM_BASE, TotalToSend);

//    while (TotalSentCount != TotalToSend) {
//    	usleep_MB(500000);
//#ifdef DEBUG
//    	xil_printf("Bytes remaining: %d      \r",UartInstancePtr->SendBuffer.RemainingBytes);
//#endif
//    }

#ifdef DEBUG
    xil_printf("\nBuffer completed: %d sent\r\n",TotalSentCount);
#endif
    //printmem();

    sleep_MB(5);

    UartNs550DisableIntrSystem(IntcInstancePtr, UartIntrId);

    return Status;

}

/*****************************************************************************/
/**
*
* This function does a minimal test on the GPIO device configured as OUTPUT.
*
* @param	None.
*
* @return	- XST_SUCCESS if the example has completed successfully.
*			- XST_FAILURE if the example has failed.
*
* @note		None.
*
****************************************************************************/

//static int GpioOutputExample(u32 LED_Value)
//{
//
//	//Change the value of the LED accordingly
//	if (LED_Value == 0xFF){
//      xil_printf("GPIO LED is off, turning on!\r");
//	} else if (LED_Value == 0x00){
//	  xil_printf("GPIO LED is on, turning off!\r");
//	} else {
//	  xil_printf("Programming LED with ASCII representation of : %c\r", LED_Value);
//	}
//
//	// Set the LED to the requested state
//	XGpio_WriteReg((GPIO_REG_BASEADDR),
//		  ((LED_CHANNEL - 1) * XGPIO_CHAN_OFFSET) +
//		  XGPIO_DATA_OFFSET, LED_Value);
//
//	// Return
//	return XST_SUCCESS;
//
//}


